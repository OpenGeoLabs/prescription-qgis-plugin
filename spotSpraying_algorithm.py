# -*- coding: utf-8 -*-

"""
/***************************************************************************
 spotSpraying
                                 A QGIS plugin
 spotSpraying
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-08-03
        copyright            : (C) 2022 by OpenGeoLabs
        email                : terezpohankova@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Tereza Pohankova'
__date__ = '2022-08-03'
__copyright__ = '(C) 2022 by OpenGeoLabs'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.core import QgsProcessing
from qgis.core import QgsProcessingAlgorithm
from qgis.core import QgsProcessingMultiStepFeedback
from qgis.core import QgsProcessingParameterRasterLayer
from qgis.core import QgsProcessingParameterNumber
from qgis.core import QgsProcessingParameterBoolean
from qgis.core import QgsProcessingParameterDistance
from qgis.core import QgsProcessingParameterFeatureSink
from qgis.core import QgsCoordinateReferenceSystem
from qgis.core import QgsExpression
import processing


class spotSprayingAlgorithm(QgsProcessingAlgorithm):
    def initAlgorithm(self, config=None):
        self.addParameter(QgsProcessingParameterRasterLayer('inputlayer', 'Input layer', defaultValue=None))
        self.addParameter(QgsProcessingParameterNumber('valueofdivide', 'Marginal Value', type=QgsProcessingParameterNumber.Double, minValue=-1, maxValue=2, defaultValue=0.6))
        self.addParameter(QgsProcessingParameterBoolean('sprayabovemarginalvalue', 'Spray above Marginal Value', defaultValue=True))
        self.addParameter(QgsProcessingParameterNumber('sievefilter', 'Sieve Pixel Filter', type=QgsProcessingParameterNumber.Double, defaultValue=3))
        self.addParameter(QgsProcessingParameterDistance('pointbuffer', 'Buffer around pixel [m]', parentParameterName='', minValue=0, maxValue=1.79769e+308, defaultValue=1))
        self.addParameter(QgsProcessingParameterNumber('sprayrate', 'Spray Rate', type=QgsProcessingParameterNumber.Double, minValue=1, maxValue=500, defaultValue=100))
        self.addParameter(QgsProcessingParameterFeatureSink('PrescriptionMap', 'Prescription Map', type=QgsProcessing.TypeVectorAnyGeometry, createByDefault=True, supportsAppend=True, defaultValue=None))

    def processAlgorithm(self, parameters, context, model_feedback):
        # Use a multi-step feedback, so that individual child algorithm progress reports are adjusted for the
        # overall progress through the model
        feedback = QgsProcessingMultiStepFeedback(11, model_feedback)
        results = {}
        outputs = {}

        # Warp (reproject)
        alg_params = {
            'DATA_TYPE': 0,  # Use Input Layer Data Type
            'EXTRA': '',
            'INPUT': parameters['inputlayer'],
            'MULTITHREADING': False,
            'NODATA': None,
            'OPTIONS': '',
            'RESAMPLING': 11,  # Third Quartile
            'SOURCE_CRS': None,
            'TARGET_CRS': QgsCoordinateReferenceSystem('EPSG:32633'),
            'TARGET_EXTENT': None,
            'TARGET_EXTENT_CRS': None,
            'TARGET_RESOLUTION': QgsExpression(' @pointbuffer').evaluate(),
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['WarpReproject'] = processing.run('gdal:warpreproject', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(1)
        if feedback.isCanceled():
            return {}

        # Conditional branch
        alg_params = {
        }
        outputs['ConditionalBranch'] = processing.run('native:condition', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(2)
        if feedback.isCanceled():
            return {}

        # Reclassify values (single)
        alg_params = {
            'INPUT': outputs['WarpReproject']['OUTPUT'],
            'NEW': 0,
            'NODATA': 0,
            'NODATAOPT': False,
            'OLD': parameters['valueofdivide'],
            'OTHEROPT': True,
            'OTHERS': parameters['sprayrate'],
            'SOPERATOR': 2,  # [2] <=
            'RESULT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['ReclassifyValuesSingle'] = processing.run('saga:reclassifyvaluessingle', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(3)
        if feedback.isCanceled():
            return {}

        # Sieve
        alg_params = {
            'EIGHT_CONNECTEDNESS': False,
            'EXTRA': '',
            'INPUT': outputs['ReclassifyValuesSingle']['RESULT'],
            'MASK_LAYER': None,
            'NO_MASK': False,
            'THRESHOLD': parameters['sievefilter'],
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['Sieve'] = processing.run('gdal:sieve', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(4)
        if feedback.isCanceled():
            return {}

        # Warp2
        alg_params = {
            'DATA_TYPE': 0,  # Use Input Layer Data Type
            'EXTRA': '',
            'INPUT': outputs['Sieve']['OUTPUT'],
            'MULTITHREADING': False,
            'NODATA': 0,
            'OPTIONS': '',
            'RESAMPLING': 0,  # Nearest Neighbour
            'SOURCE_CRS': None,
            'TARGET_CRS': None,
            'TARGET_EXTENT': None,
            'TARGET_EXTENT_CRS': None,
            'TARGET_RESOLUTION': None,
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['Warp2'] = processing.run('gdal:warpreproject', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(5)
        if feedback.isCanceled():
            return {}

        # Raster pixels above
        alg_params = {
            'FIELD_NAME': 'RATE',
            'INPUT_RASTER': outputs['Warp2']['OUTPUT'],
            'RASTER_BAND': 1,
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['RasterPixelsAbove'] = processing.run('native:pixelstopoints', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(6)
        if feedback.isCanceled():
            return {}

        # Invert data/no-data
        alg_params = {
            'INPUT': outputs['Warp2']['OUTPUT'],
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['InvertDatanodata'] = processing.run('saga:invertdatanodata', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(7)
        if feedback.isCanceled():
            return {}

        # Raster pixels below
        alg_params = {
            'FIELD_NAME': 'RATE',
            'INPUT_RASTER': outputs['InvertDatanodata']['OUTPUT'],
            'RASTER_BAND': 1,
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['RasterPixelsBelow'] = processing.run('native:pixelstopoints', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(8)
        if feedback.isCanceled():
            return {}

        # Buffer
        alg_params = {
            'DISSOLVE': True,
            'DISTANCE': parameters['pointbuffer'],
            'END_CAP_STYLE': 0,  # Round
            'INPUT': QgsExpression('if( @sprayabovemarginalvalue, @Raster_pixels_above_OUTPUT , @Raster_pixels_below_OUTPUT )').evaluate(),
            'JOIN_STYLE': 0,  # Round
            'MITER_LIMIT': 2,
            'SEGMENTS': 5,
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['Buffer'] = processing.run('native:buffer', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(9)
        if feedback.isCanceled():
            return {}

        # Field calculator
        alg_params = {
            'FIELD_LENGTH': 5,
            'FIELD_NAME': 'RATE',
            'FIELD_PRECISION': 0,
            'FIELD_TYPE': 0,  # Float
            'FORMULA': ' @sprayrate ',
            'INPUT': outputs['Buffer']['OUTPUT'],
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['FieldCalculator'] = processing.run('native:fieldcalculator', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(10)
        if feedback.isCanceled():
            return {}

        # Reproject layer
        alg_params = {
            'INPUT': outputs['FieldCalculator']['OUTPUT'],
            'OPERATION': '',
            'TARGET_CRS': QgsCoordinateReferenceSystem('EPSG:4326'),
            'OUTPUT': parameters['PrescriptionMap']
        }
        outputs['ReprojectLayer'] = processing.run('native:reprojectlayer', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
        results['PrescriptionMap'] = outputs['ReprojectLayer']['OUTPUT']
        return results

    def name(self):
        return 'PrescriptionMap Creator'

    def displayName(self):
        return 'PrescriptionMap Creator'

    def group(self):
        return 'SpotSpraying'

    def groupId(self):
        return 'SpotSpraying'

    def createInstance(self):
        return spotSprayingAlgorithm()
